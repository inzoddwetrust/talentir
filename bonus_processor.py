import logging
from typing import List
from datetime import datetime
from sqlalchemy.orm import Session

from database import User, Purchase, Bonus, Notification, PassiveBalance
from templates import MessageTemplates
from init import Session
import config

logger = logging.getLogger(__name__)


async def process_purchase_bonuses(session: Session, purchase: Purchase) -> List[Bonus]:
    """
    Processes referral bonuses for a purchase
    Returns list of created bonuses
    """
    created_bonuses = []
    current_user = purchase.user
    level = 1

    while True:
        # Stop if we've reached the default referrer or max levels
        if (not current_user.upline or
                current_user.upline == config.DEFAULT_REFERRER_ID or
                f"level_{level}" not in config.PURCHASE_BONUSES):
            break

        # Get upline user
        upline_user = session.query(User).filter_by(
            telegramID=current_user.upline
        ).first()

        if not upline_user:
            logger.warning(f"Upline user not found for user {current_user.userID}")
            break

        # Calculate bonus
        bonus_rate = config.PURCHASE_BONUSES[f"level_{level}"] / 100.0
        bonus_amount = purchase.packPrice * bonus_rate  # Используем packPrice вместо amount

        now = datetime.utcnow()
        bonus = Bonus(
            userID=upline_user.userID,
            downlineID=purchase.userID,
            purchaseID=purchase.purchaseID,
            projectID=purchase.projectID,
            optionID=purchase.optionID,
            packQty=purchase.packQty,
            packPrice=purchase.packPrice,
            uplineLevel=level,
            bonusRate=bonus_rate,
            bonusAmount=bonus_amount,
            status="paid",
            createdAt=now,
            notes="autogenerated:1"
        )
        session.add(bonus)
        session.flush()

        # Update user's passive balance
        upline_user.balancePassive += bonus_amount

        # Создаем запись в PassiveBalance
        passive_balance_record = PassiveBalance(
            userID=upline_user.userID,
            firstname=upline_user.firstname,
            surname=upline_user.surname,
            amount=bonus_amount,  # Положительная сумма для начисления
            status='done',
            reason=f'bonus={bonus.bonusID}',  # ID бонуса как reason
            link='',  # Пока пустой
            notes=f'Referral bonus level {level}'
        )
        session.add(passive_balance_record)

        # Create notification
        await create_bonus_notification(session, bonus, upline_user)

        created_bonuses.append(bonus)

        # Move up the chain
        current_user = upline_user
        level += 1

    return created_bonuses


async def create_bonus_notification(session: Session, bonus: Bonus, user: User) -> None:
    """Creates notification about received bonus"""
    try:
        text, buttons = await MessageTemplates.get_raw_template(
            'bonus_received',
            {
                'bonus_amount': bonus.bonusAmount,
                'purchase_amount': bonus.packPrice,
                'downline_level': bonus.uplineLevel,
                'project_id': bonus.projectID
            },
            lang=user.lang
        )

        notification = Notification(
            source="bonus_processor",
            text=text,
            buttons=buttons,
            target_type="user",
            target_value=str(user.userID),
            priority=2,
            category="bonus",
            importance="high",
            parse_mode="HTML"
        )

        session.add(notification)

    except Exception as e:
        logger.error(f"Error creating bonus notification: {e}")


async def process_purchase_with_bonuses(purchase_id: int) -> None:
    """
    Wrapper function to process purchase bonuses in a separate transaction
    """
    session = Session()  # Создаем сессию напрямую
    try:
        # Загружаем покупку со всеми необходимыми связями
        purchase = (
            session.query(Purchase)
                .filter_by(purchaseID=purchase_id)
                .join(Purchase.user)
                .first()
        )

        if not purchase:
            logger.error(f"Purchase {purchase_id} not found")
            return

        await process_purchase_bonuses(session, purchase)
        session.commit()
        logger.info(f"Successfully processed bonuses for purchase {purchase_id}")

    except Exception as e:
        session.rollback()
        logger.error(f"Error processing bonuses for purchase {purchase_id}: {e}")
        logger.exception("Full traceback:")
    finally:
        session.close()  # Важно закрыть сессию