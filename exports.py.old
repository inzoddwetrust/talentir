import asyncio
import logging
from datetime import datetime
from typing import Dict, List
from sqlalchemy.orm import Session

from database import User, Payment, Purchase, Bonus, Transfer, ActiveBalance, PassiveBalance
from init import Session
from google_services import get_google_services
import config

logger = logging.getLogger(__name__)


class SheetsExporter:
    def __init__(self, update_interval: int = 60, logger=None):
        """
        Сервис экспорта данных из SQLite в Google Sheets

        Args:
            update_interval: интервал обновления в секундах (по умолчанию 60)
            logger: логгер (если None, будет создан новый)
        """
        self.update_interval = update_interval
        self.sheets_client = None
        self.worksheets = {}
        self._running = False
        self.logger = logger or logging.getLogger('exports')

        # Метаданные последней синхронизации
        self.last_sync = {
            'users': None,
            'payments': None,
            'purchases': None,
            'bonuses': None,
            'activebalance': None,
            'passivebalance': None,
            'transfers': None
        }

    async def start(self):
        """Запуск сервиса экспорта"""
        if self._running:
            logger.warning("Exporter is already running")
            return

        self._running = True
        logger.info("Starting Google Sheets exporter")
        await self.run()

    async def stop(self):
        """Остановка сервиса"""
        self._running = False
        logger.info("Stopping Google Sheets exporter")

    async def connect(self):
        """Установка соединения с Google Sheets"""
        try:
            self.sheets_client, _ = get_google_services()

            # Получаем доступ к нужным листам
            spreadsheet = self.sheets_client.open_by_key(config.GOOGLE_SHEET_ID)
            self.worksheets = {
                'users': spreadsheet.worksheet("Users"),
                'payments': spreadsheet.worksheet("Payments"),
                'purchases': spreadsheet.worksheet("Purchases"),
                'bonuses': spreadsheet.worksheet("Bonuses"),
                'activebalance': spreadsheet.worksheet("ActiveBalance"),
                'passivebalance': spreadsheet.worksheet("PassiveBalance"),
                'transfers': spreadsheet.worksheet("Transfers")
            }
            logger.info("Successfully connected to Google Sheets")

        except Exception as e:
            logger.error(f"Failed to connect to Google Sheets: {e}")
            raise

    async def sync_users(self, session: Session) -> None:
        """Синхронизация данных пользователей"""
        try:
            sheet = self.worksheets['users']
            # Получаем все записи с их индексами
            records = sheet.get_all_records()
            sheet_data = {
                str(row["userID"]): {"data": row, "row_index": idx + 2}  # +2 потому что первая строка - заголовки
                for idx, row in enumerate(records)
            }

            # Получаем всех пользователей из БД
            db_users = session.query(User).all()

            updates = []
            new_records = []

            for user in db_users:
                user_data = self.format_user_data(user)
                sheet_row = sheet_data.get(str(user.userID))

                if sheet_row:
                    # Проверяем необходимость обновления
                    if self.user_needs_update(user_data, sheet_row["data"]):
                        self.logger.debug(f"User {user.userID} needs update")
                        updates.append((sheet_row["row_index"], user_data))
                else:
                    self.logger.debug(f"User {user.userID} will be added as new")
                    new_records.append(user_data)

            # Применяем изменения батчами
            if updates:
                for batch in self.batch(updates, 50):  # Google Sheets API limit
                    for row_idx, data in batch:
                        sheet.update(f"A{row_idx}:V{row_idx}", [data])  # Updated from U to V

            if new_records:
                for batch in self.batch(new_records, 50):
                    sheet.append_rows(batch)

            self.last_sync['users'] = datetime.now()
            logger.info(f"Users sync completed: {len(updates)} updated, {len(new_records)} added")

        except Exception as e:
            logger.error(f"Error syncing users: {e}")

    async def sync_payments(self, session: Session) -> None:
        """Синхронизация платежей"""
        try:
            sheet = self.worksheets['payments']
            sheet_data = {str(row["paymentID"]): row for row in sheet.get_all_records()}

            db_payments = session.query(Payment).all()
            new_records = []

            for payment in db_payments:
                if str(payment.paymentID) not in sheet_data:
                    payment_data = [
                        payment.paymentID,
                        payment.createdAt.strftime("%Y-%m-%d %H:%M:%S") if payment.createdAt else "",
                        payment.userID,
                        payment.firstname,
                        payment.surname,
                        payment.direction,
                        payment.amount,
                        payment.method,
                        payment.fromWallet or "",
                        payment.toWallet or "",
                        payment.txid or "",
                        payment.sumCurrency,
                        payment.status,
                        payment.confirmedBy or "",
                        payment.confirmationTime.strftime("%Y-%m-%d %H:%M:%S") if payment.confirmationTime else "",
                    ]
                    new_records.append(payment_data)

            if new_records:
                for batch in self.batch(new_records, 50):
                    sheet.append_rows(batch)

            self.last_sync['payments'] = datetime.now()
            logger.info(f"Payments sync completed: {len(new_records)} new records added")

        except Exception as e:
            logger.error(f"Error syncing payments: {e}")

    async def sync_purchases(self, session: Session) -> None:
        """Синхронизация покупок"""
        try:
            sheet = self.worksheets['purchases']
            sheet_data = {str(row["purchaseID"]): row for row in sheet.get_all_records()}

            db_purchases = session.query(Purchase).all()
            new_records = []

            for purchase in db_purchases:
                if str(purchase.purchaseID) not in sheet_data:
                    purchase_data = [
                        purchase.purchaseID,
                        purchase.createdAt.strftime("%Y-%m-%d %H:%M:%S") if purchase.createdAt else "",
                        purchase.userID,
                        purchase.projectID,
                        purchase.projectName,
                        purchase.optionID,
                        purchase.packQty,
                        purchase.packPrice,
                    ]
                    new_records.append(purchase_data)

            if new_records:
                for batch in self.batch(new_records, 50):
                    sheet.append_rows(batch)

            self.last_sync['purchases'] = datetime.now()
            logger.info(f"Purchases sync completed: {len(new_records)} new records added")

        except Exception as e:
            logger.error(f"Error syncing purchases: {e}")

    async def sync_bonuses(self, session: Session) -> None:
        """Синхронизация бонусов"""
        try:
            sheet = self.worksheets['bonuses']
            sheet_data = {str(row["bonusID"]): row for row in sheet.get_all_records()}

            db_bonuses = session.query(Bonus).all()
            new_records = []

            for bonus in db_bonuses:
                if str(bonus.bonusID) not in sheet_data:
                    bonus_data = [
                        bonus.bonusID,
                        bonus.createdAt.strftime("%Y-%m-%d %H:%M:%S") if bonus.createdAt else "",
                        bonus.userID,
                        bonus.downlineID,
                        bonus.purchaseID,
                        bonus.projectID,
                        bonus.optionID,
                        bonus.packQty,
                        bonus.packPrice,
                        bonus.uplineLevel,
                        bonus.bonusRate,
                        bonus.bonusAmount,
                        bonus.status,
                        bonus.notes or ""
                    ]
                    new_records.append(bonus_data)

            if new_records:
                for batch in self.batch(new_records, 50):
                    sheet.append_rows(batch)

            self.last_sync['bonuses'] = datetime.now()
            logger.info(f"Bonuses sync completed: {len(new_records)} new records added")

        except Exception as e:
            logger.error(f"Error syncing bonuses: {e}")

    async def sync_active_balance(self, session: Session) -> None:
        """Синхронизация записей активного баланса"""
        try:
            sheet = self.worksheets['activebalance']
            sheet_data = {str(row["paymentID"]): row for row in sheet.get_all_records()}

            records = session.query(ActiveBalance).all()
            new_records = []

            for record in records:
                if str(record.paymentID) not in sheet_data:
                    record_data = [
                        record.paymentID,
                        record.createdAt.strftime("%Y-%m-%d %H:%M:%S") if record.createdAt else "",
                        record.userID,
                        record.firstname,
                        record.surname or "",
                        record.amount,
                        record.status,
                        record.reason,
                        record.link or "",
                        record.notes or ""
                    ]
                    new_records.append(record_data)

            if new_records:
                for batch in self.batch(new_records, 50):
                    sheet.append_rows(batch)

            self.last_sync['activebalance'] = datetime.now()
            logger.info(f"Active balance sync completed: {len(new_records)} new records added")

        except Exception as e:
            logger.error(f"Error syncing active balance: {e}")

    async def sync_passive_balance(self, session: Session) -> None:
        """Синхронизация записей пассивного баланса"""
        try:
            sheet = self.worksheets['passivebalance']
            sheet_data = {str(row["paymentID"]): row for row in sheet.get_all_records()}

            records = session.query(PassiveBalance).all()
            new_records = []

            for record in records:
                if str(record.paymentID) not in sheet_data:
                    record_data = [
                        record.paymentID,
                        record.createdAt.strftime("%Y-%m-%d %H:%M:%S") if record.createdAt else "",
                        record.userID,
                        record.firstname,
                        record.surname or "",
                        record.amount,
                        record.status,
                        record.reason,
                        record.link or "",
                        record.notes or ""
                    ]
                    new_records.append(record_data)

            if new_records:
                for batch in self.batch(new_records, 50):
                    sheet.append_rows(batch)

            self.last_sync['passivebalance'] = datetime.now()
            logger.info(f"Passive balance sync completed: {len(new_records)} new records added")

        except Exception as e:
            logger.error(f"Error syncing passive balance: {e}")

    async def sync_transfers(self, session: Session) -> None:
        """Синхронизация переводов"""
        try:
            sheet = self.worksheets['transfers']
            sheet_data = {str(row["transferID"]): row for row in sheet.get_all_records()}

            transfers = session.query(Transfer).all()
            new_records = []

            for transfer in transfers:
                if str(transfer.transferID) not in sheet_data:
                    transfer_data = [
                        transfer.transferID,
                        transfer.createdAt.strftime("%Y-%m-%d %H:%M:%S") if transfer.createdAt else "",
                        transfer.senderUserID,
                        transfer.senderFirstname,
                        transfer.senderSurname or "",
                        transfer.fromBalance,
                        transfer.amount,
                        transfer.recieverUserID,
                        transfer.receiverFirstname,
                        transfer.receiverSurname or "",
                        transfer.toBalance,
                        transfer.status,
                        transfer.notes or ""
                    ]
                    new_records.append(transfer_data)

            if new_records:
                for batch in self.batch(new_records, 50):
                    sheet.append_rows(batch)

            self.last_sync['transfers'] = datetime.now()
            logger.info(f"Transfers sync completed: {len(new_records)} new records added")

        except Exception as e:
            logger.error(f"Error syncing transfers: {e}")

    @staticmethod
    def format_user_data(user: User) -> List:
        """Форматирование данных пользователя для Google Sheets"""
        return [
            user.userID,
            user.createdAt.strftime("%Y-%m-%d %H:%M:%S") if user.createdAt else "",
            user.upline or "",
            user.lang or "",
            user.firstname or "",
            user.surname or "",
            user.birthday.strftime("%Y-%m-%d") if user.birthday else "",
            user.address or "",
            user.phoneNumber or "",
            user.city or "",
            user.country or "",
            user.passport or "",  # New field
            user.telegramID,
            user.email or "",
            user.balanceActive,
            user.balancePassive,
            int(user.isFilled),
            int(user.kyc),
            user.lastActive.strftime("%Y-%m-%d %H:%M:%S") if user.lastActive else "",
            user.status or "active",
            user.notes or "",
            user.settings or ""
        ]

    @staticmethod
    def batch(iterable, size):
        """Разбивка списка на батчи"""
        length = len(iterable)
        for ndx in range(0, length, size):
            yield iterable[ndx:min(ndx + size, length)]

    def user_needs_update(self, user_data: List, sheet_row: Dict) -> bool:
        """Проверка необходимости обновления данных пользователя"""
        key_fields = {
            'firstname': 4,
            'surname': 5,
            'birthday': 6,
            'address': 7,
            'phoneNumber': 8,
            'city': 9,
            'country': 10,
            'passport': 11,  # New field
            'email': 13,  # Shifted
            'balanceActive': 14,  # Shifted
            'balancePassive': 15,  # Shifted
            'isFilled': 16,  # Shifted
            'kyc': 17,  # Shifted
            'lastActive': 18,  # Shifted
            'status': 19,  # Shifted
            'notes': 20,  # Shifted
            'settings': 21  # Shifted
        }

        for field, idx in key_fields.items():
            sheet_value = sheet_row.get(field, '')
            user_value = user_data[idx]

            # Специальная обработка для числовых полей
            if field in ['balanceActive', 'balancePassive']:
                try:
                    sheet_num = float(sheet_value) if sheet_value != '' else 0.0
                    user_num = float(user_value)
                    if abs(sheet_num - user_num) > 0.001:  # Сравниваем с погрешностью
                        self.logger.debug(
                            f"Field {field} needs update: sheet={sheet_num} != user={user_num}"
                        )
                        return True
                    continue
                except (ValueError, TypeError):
                    return True

            # Специальная обработка для булевых полей
            elif field in ['isFilled', 'kyc']:
                sheet_bool = bool(int(sheet_value)) if sheet_value != '' else False
                user_bool = bool(int(user_value))
                if sheet_bool != user_bool:
                    self.logger.debug(
                        f"Field {field} needs update: sheet={sheet_bool} != user={user_bool}"
                    )
                    return True
                continue

            # Для всех остальных полей - строковое сравнение с учетом пустых значений
            sheet_str = str(sheet_value).strip() if sheet_value not in [None, ''] else ''
            user_str = str(user_value).strip() if user_value not in [None, ''] else ''

            if sheet_str != user_str:
                self.logger.debug(
                    f"Field {field} needs update: sheet='{sheet_str}' != user='{user_str}'"
                )
                return True

        return False

    async def run(self):
        """Основной цикл экспорта"""
        await asyncio.sleep(300)  # First 5 minutes of run no any updates

        while self._running:
            try:
                if not self.sheets_client:
                    await self.connect()

                with Session() as session:
                    await self.sync_users(session)
                    await self.sync_payments(session)
                    await self.sync_purchases(session)
                    await self.sync_bonuses(session)
                    await self.sync_active_balance(session)
                    await self.sync_passive_balance(session)
                    await self.sync_transfers(session)

            except Exception as e:
                logger.error(f"Export error: {e}")
                # При ошибке подключения пробуем переподключиться в следующей итерации
                self.sheets_client = None

            await asyncio.sleep(self.update_interval)
